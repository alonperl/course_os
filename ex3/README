griffonn, ednussi
Gregory Pasternak (327148417), Eran Nussinovitch (302186408)
Ex: 3

FILES:
README
Makefile
Request.cpp
Request.hpp
Block.cpp
Block.hpp
blockchain.cpp
blockchain.h
Chain.cpp
Chain.hpp
hash.h
libhash.a

REMARKS: NONE

Explantion on how and why library functions are the way they are:
Our design:

-blockchain
	-Chain
		-Block
		-Request

Understanding there is more than one thread working and dealing with the same 
data structures we realized that mutexes, conditional variables and signals will
be needed in order to maintain order and avoid chaos throughout our program.

We have created a main singelton class called "Chain" which is the main structure
of our blockchain. The chain consits of "Block"s each containing the required 
information about itself and only knows its own father - just like the real bitcoin
blockchain.
Within chain, a daemon thread is created in order to manage the chain and the 
requests given in.

Roughly we chose to avoid a main static mutex to lock everyone in order to 
maintain some sort of multi-threading ability. We did create multiple mutexs for
our diffrent data structures inside Chain class such as recycled ids list, block
maps and vectors for the various information that we required.

In addition to mutexes, as mentioned before, in certain places we needed to create
a conditional waiting for something else to happen, using conditional variables.
We have two CVs: first blocks daemon thread until there are new addition requests,
and second is in attach_now and blocks calling thread until desired block is 
actually attached to the chain.

Additional information regarding the lock and unlock of each mutex is in comments
within our program. Generally speaking whenever there is a part of code which 
checks or need to access a data structure to read or alter some part in it we 
will lock it before and release it as soon as possible. The only exception is 
when closing the chain.

ANSWERS TO QUESTIONS:

1. 
It is the delayed attachment, meaning the block is only attached to the chain 
only when its hashing is finished and can only then be a father of another block.
The hashing time compared to the time between request is the main parameter which
affects, and yes we can change it by shortening or prolonging each one.

2.
By Chosing a father only when attaching a block, using a mutex on the chain, we 
can make sure that there will only be one long chain. In this Ex we can just mark
all of the Blocks by toLongest() from its creation.

3.
One of the race conditions we didn't deal with is prioriting in some way the 
Blocks by the time in which the information was recieved or the data that's inside.